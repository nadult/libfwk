// Copyright (C) Krzysztof Jakubowski <nadult@fastmail.fm>
// This file is part of libfwk. See license.txt for details.

#pragma once

#include "fwk/enum.h"
#include "fwk/math_base.h"
#include "fwk/str.h"
#include "fwk/sys/expected.h"

namespace fwk {

class TextParser;
struct NotParsable;

namespace detail {

	template <class T> struct IsParsable {
		template <class U> static auto test(U &) -> decltype(DECLVAL(TextParser &) >> DECLVAL(U &));
		static char test(...);
		static constexpr bool value = is_same<decltype(test(DECLVAL(T &))), TextParser &>;
	};

	template <class T> struct VariableParseElements { static constexpr bool value = false; };
	template <class T> struct VariableParseElements<vector<T>> {
		static constexpr bool value = true;
	};
}

template <class T> constexpr bool is_parsable = detail::IsParsable<T>::value;
template <class... Args> using EnableIfParsable = EnableIf<(... && is_parsable<Args>), NotParsable>;

// Parsing white-space separated elements
// Output generated by TextFormatter in plain mode can be parsed
// Errors will be stored in Error register (see fwk/sys/error.h)
// TODO: strings with whitespace in them
// TODO: drop requirement of 0-termination
class TextParser {
  public:
	TextParser(ZStr str) : m_current(str) {}

	// These will work even when parser is empty
	TextParser &operator>>(Str &);
	TextParser &operator>>(string &);

	TextParser &operator>>(bool &);
	TextParser &operator>>(double &);
	TextParser &operator>>(float &);
	TextParser &operator>>(short &);
	TextParser &operator>>(unsigned short &);
	TextParser &operator>>(int &);
	TextParser &operator>>(unsigned int &);
	TextParser &operator>>(long &);
	TextParser &operator>>(unsigned long &);
	TextParser &operator>>(long long &);
	TextParser &operator>>(unsigned long long &);

	template <class TSpan, class T = SpanBase<TSpan>, EnableIfParsable<T>...>
	void parseSpan(TSpan &span) {
		for(auto &elem : span)
			*this >> elem;
	}

	void parseNotEmpty(Span<Str>);
	void parseNotEmpty(Span<string>);
	void parseInts(Span<int>);
	void parseFloats(Span<float>);
	void parseDoubles(Span<double>);

	Str current() const { return m_current; }
	void advance(int offset) { m_current = m_current.advance(offset); }

	bool empty() const { return m_current.empty(); }

	// Also skips whitespace on both sides
	Str parseElement();
	void advanceWhitespace();
	int countElements() const;

	void parseUints(Span<uint> out);
	void parseStrings(Span<string> out);

	template <class T, EnableIfParsable<T>...> T parse() {
		T value;
		*this >> value;
		return value;
	}

	void errorTrailingData();

  private:
	ZStr m_current;
};

// To make new type parsable: simply overload operator<<:
// TextParser &operator>>(TextParser&, MyNewType &rhs);

TextParser &operator>>(TextParser &, short2 &);
TextParser &operator>>(TextParser &, short3 &);
TextParser &operator>>(TextParser &, short4 &);
TextParser &operator>>(TextParser &, int2 &);
TextParser &operator>>(TextParser &, int3 &);
TextParser &operator>>(TextParser &, int4 &);
TextParser &operator>>(TextParser &, double2 &);
TextParser &operator>>(TextParser &, double3 &);
TextParser &operator>>(TextParser &, double4 &);
TextParser &operator>>(TextParser &, float2 &);
TextParser &operator>>(TextParser &, float3 &);
TextParser &operator>>(TextParser &, float4 &);
TextParser &operator>>(TextParser &, DRect &);
TextParser &operator>>(TextParser &, FRect &);
TextParser &operator>>(TextParser &, IRect &);
TextParser &operator>>(TextParser &, FBox &);
TextParser &operator>>(TextParser &, IBox &);
TextParser &operator>>(TextParser &, DBox &);
TextParser &operator>>(TextParser &, Matrix4 &);
TextParser &operator>>(TextParser &, Quat &);

TextParser &operator>>(TextParser &, vector<string> &);
TextParser &operator>>(TextParser &, vector<int> &);
TextParser &operator>>(TextParser &, vector<float> &);

template <class T, EnableIfParsable<T>..., EnableIf<!detail::VariableParseElements<T>::value>...>
TextParser &operator>>(TextParser &parser, vector<T> &vec) {
	parser.advanceWhitespace();
	vec.clear();
	while(!parser.empty()) {
		vec.emplace_back();
		parser >> vec.back();
	}
	return parser;
}

// TODO: parsing types from math
// TODO: with this kind of error reporting, we can use constructors ?

template <class T, EnableIf<is_parsable<T> && !is_enum<T>>...> T fromString(ZStr str) {
	TextParser parser(str);
	T out;
	parser >> out;
	if(!parser.empty()) {
		out = T();
		parser.errorTrailingData();
	}
	return out;
}

// TODO: inconsistency with tryFromString(enum)
template <class T, EnableIf<is_parsable<T> && !is_enum<T>>...> Expected<T> tryFromString(ZStr str) {
	auto ret = fromString<T>(str);
	EXPECT_NO_ERRORS();
	return ret;
}
}
